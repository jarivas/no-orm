<?php

namespace Entity;

use PDO;

class Connection {
    protected $host = '{{host}}';
    protected $dbname = '{{dbname}}';
    protected $username = '{{username}}';
    protected $password = '{{password}}';
    protected $db = null;
    protected static $instance = null;

    public static $callAllowedTypes = ['set', 'get'];

    public function __construct()
    {
        $this->db = new PDO("mysql:host={$this->host};dbname={$this->dbname}", $this->username, $this->password);
    }

    /**
     * Retrieves an array of the used Entity
     * @param string $sql
     * @param string $className
     * @return array[Entity]
     */
    public function get(string $sql, string $className) {
        $stmt = $this->db->query($sql, PDO::FETCH_CLASS, $className);
        return $stmt->fetchAll();
    }

    /** Executes the sql and returns the numbers of rows affected
     * @param $sql
     * @return int
     */
    public function executeSql($sql) {
        return $this->db->exec($sql);
    }

    /**
     * Limit the connections created to one
     * @return Connection|null
     */
    public static function getInstance()
    {
        if (self::$instance == null) self::$instance = new self();

        return self::$instance;
    }


    // SQL GENERATORS

    protected static function generateConditions(string $type, array $conditions) : string
    {
        $sql = '';

        if (count($conditions)) {
            $sql .= " $type 1";

            foreach ($conditions as $condition)
                $sql .= ' ' . $condition['operator'] . ' ' . $condition['condition'];
        }

        return $sql;
    }

    public static function generateSelect(string $tableName, array $projection, array $where = [], string $group = '', array $having = [], string $order = '', int $limit = 1000, int $offset = 0) : string
    {
        $sql = 'SELECT ';

        foreach ($projection as $col)
            $sql .= $col . ', ';

        $sql = substr_replace($sql," FROM {$tableName}", strlen($sql) - 3);

        $sql .= self::generateConditions('WHERE', $where);

        if (strlen($group))
            $sql .= ' GROUP BY ' . $group;

        $sql .= self::generateConditions('HAVING', $having);

        if (strlen($order))
            $sql .= ' ORDER BY ' . $order;

        $sql .= sprintf(' LIMIT %d OFFSET %d', $limit, $offset);

        return $sql;
    }

    public static function generateInsert(string $tableName, array $columns, array $values, string $onDuplicateKeyUpdate = '') : string
    {
        $sql = sprintf('INSERT INTO %s (', $tableName);

        foreach ($columns as $column)
            $sql .= $column . ', ';

        $sql = substr_replace($sql,") VALUES (", strlen($sql) - 3);

        foreach ($values as $value)
            $sql .= sprintf('"%s", ', $value);

        $sql = substr_replace($sql,")", strlen($sql) - 3);

        if(strlen($onDuplicateKeyUpdate))
            $sql .= 'ON DUPLICATE KEY UPDATE '. $onDuplicateKeyUpdate;

        return $sql;
    }

    public static function generateUpdate(string $tableName, array $assignments, array $where = [], string $order = '', int $limit = 0){
        $sql = 'UPDATE ' . $tableName . ' SET ';

        foreach ($assignments as $assignment)
            $sql .= $assignment . ', ';

        $sql = substr($sql, 0, strlen($sql) - 3) . self::generateConditions('WHERE', $where);

        if (strlen($order))
            $sql .= ' ORDER BY ' . $order;

        $sql .= sprintf(' LIMIT %d', $limit);

        return $sql;
    }

    public static function generateDelete(string $tableName, array $where = [], string $order = '', int $limit = 0) : string
    {
        $sql = 'DELETE FROM ' . $tableName . self::generateConditions('WHERE', $where);

        if (strlen($order))
            $sql .= ' ORDER BY ' . $order;

        $sql .= sprintf(' LIMIT %d', $limit);

        return $sql;
    }
}
